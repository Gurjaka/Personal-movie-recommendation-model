{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"\ud83c\udfac Personalized Movie Recommendation System Final Project for the TBC x Geolab Bootcamp A smart, personalized movie recommendation system that suggests films tailored to each user's unique taste."},{"location":"#project-structure","title":"\ud83d\udcc2 Project Structure","text":"<pre><code>Personal-Movie-Recommendation-System/\n\u251c\u2500\u2500 data/               # Dataset CSV files (movies.csv, ratings.csv, etc.)\n\u251c\u2500\u2500 src/                # Source code\n\u2502   \u251c\u2500\u2500 main.py         # Main entry point\n\u2502   \u251c\u2500\u2500 train.py        # (Optional) Model training scripts\n\u2502   \u251c\u2500\u2500 utils.py        # Utility functions for data handling\n\u2502   \u2514\u2500\u2500 test.py         # (Optional) Test scripts\n\u251c\u2500\u2500 .envrc              # Environment config (direnv)\n\u251c\u2500\u2500 .gitignore          # Git ignore rules\n\u251c\u2500\u2500 flake.nix           # Nix shell configuration\n\u2514\u2500\u2500 flake.lock          # Nix lock file\n</code></pre>"},{"location":"#where-to-get-the-dataset","title":"\ud83d\udce5 Where to Get the Dataset","text":"<p>You can download the required datasets from Kaggle: Movie Recommendation System Dataset</p> <p>Make sure to download and place the files (<code>movies.csv</code>, <code>ratings.csv</code>, etc.) inside the <code>data/</code> folder</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83d\udcca Efficient loading and merging of movie metadata and user ratings</li> <li>\ud83d\udc64 Builds personalized user profiles from favorite movies, genres, and rating timestamps</li> <li>\ud83d\udd0d Finds users with similar tastes for collaborative recommendations</li> <li>\ud83c\udfaf Recommends highly rated movies from similar users that the target user hasn\u2019t seen</li> <li>\ud83e\udd1d Combines content-based filtering (genres) with collaborative filtering (user similarity) for hybrid recommendations</li> </ul>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>Check the Usage Guide to get started.</p>"},{"location":"#branding-notice","title":"\ud83d\udccc Branding Notice","text":"<p>This project was created as part of the TBC x Geolab Bootcamp. The TBC logo and related branding are owned by their respective entities and may not be reused, modified, or redistributed without permission.</p> <p>Feel free to fork or use the code under the terms of the MIT license \u2014 but do not use the TBC logo or project branding in your own versions or hosted apps.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>MIT Licensed \u2013 See LICENSE for details</p>"},{"location":"about/","title":"\ud83d\udc65 About the Project","text":"\ud83c\udfac Personalized Movie Recommendation System  Final Project for the TBC x Geolab Bootcamp   A smart movie recommender built to tailor film suggestions based on each user's unique taste \u2014 combining the strengths of content-based and collaborative filtering."},{"location":"about/#project-authors","title":"\ud83d\udc68\u200d\ud83d\udcbb Project Authors","text":""},{"location":"about/#gurami-esartia-lead-developer","title":"\ud83e\udde0 Gurami Esartia \u2013 Lead Developer","text":"<ul> <li>\ud83d\udcbc Architected and implemented the entire system  </li> <li>\ud83e\uddee Developed and trained the hybrid recommendation model  </li> <li>\ud83c\udfa8 Designed the Gradio interface  </li> <li>\ud83d\udcdd Authored documentation and handled deployment  </li> <li>\ud83d\udd17 github.com/gurjaka</li> </ul>"},{"location":"about/#vasil-lekiashvili-contributor","title":"\ud83e\udd1d Vasil Lekiashvili \u2013 Contributor","text":"<ul> <li>\ud83e\uddea Assisted with data cleaning and testing  </li> <li>\ud83d\udca1 Collaborated on model brainstorming  </li> <li>\ud83d\udcc4 Authored the final project report </li> <li>\ud83d\udd17 github.com/Lol0kv28</li> </ul>"},{"location":"about/#license-credits","title":"\ud83d\udcdc License &amp; Credits","text":"<p>This project is distributed under the MIT License.  </p> <p>\u26a0\ufe0f The TBC logo, name, and branding are excluded from the MIT license. They remain the property of their respective owners and are used here strictly for educational and non-commercial purposes.</p>    Built with \u2764\ufe0f for learning and growth     \u2728 Powered by Python, Gradio, Scikit-learn &amp; MkDocs Material"},{"location":"report/","title":"Movie Recommendation System: Project Report and Overview","text":"\ud83c\uddec\ud83c\uddea \u10e5\u10d0\u10e0\u10d7\u10e3\u10da\u10d8 \u10d5\u10d4\u10e0\u10e1\u10d8\u10d0 (Georgian Version) \ud83c\uddfa\ud83c\uddf8 English Version"},{"location":"report/#_1","title":"\u10e4\u10d8\u10da\u10db\u10d4\u10d1\u10d8\u10e1 \u10e0\u10d4\u10d9\u10dd\u10db\u10d4\u10dc\u10d3\u10d0\u10ea\u10d8\u10d8\u10e1 \u10e1\u10d8\u10e1\u10e2\u10d4\u10db\u10d0: \u10de\u10e0\u10dd\u10d4\u10e5\u10e2\u10d8\u10e1 \u10e0\u10d4\u10de\u10dd\u10e0\u10e2\u10d8 \u10d3\u10d0 \u10db\u10d8\u10db\u10dd\u10ee\u10d8\u10da\u10d5\u10d0","text":"<p>\u10e9\u10d5\u10d4\u10dc \u10e8\u10d4\u10d5\u10e5\u10db\u10d4\u10dc\u10d8\u10d7 \u10f0\u10d8\u10d1\u10e0\u10d8\u10d3\u10e3\u10da\u10d8 \u10e4\u10d8\u10da\u10db\u10d4\u10d1\u10d8\u10e1 \u10e0\u10d4\u10d9\u10dd\u10db\u10d4\u10dc\u10d3\u10d0\u10ea\u10d8\u10d8\u10e1 \u10e1\u10d8\u10e1\u10e2\u10d4\u10db\u10d0, \u10e0\u10dd\u10db\u10d4\u10da\u10d8\u10ea \u10d0\u10d4\u10e0\u10d7\u10d8\u10d0\u10dc\u10d4\u10d1\u10e1 \u10e8\u10d8\u10dc\u10d0\u10d0\u10e0\u10e1\u10d6\u10d4 \u10d3\u10d0\u10e4\u10e3\u10eb\u10dc\u10d4\u10d1\u10e3\u10da \u10e4\u10d8\u10da\u10e2\u10e0\u10d0\u10ea\u10d8\u10d0\u10e1 \u10e4\u10d8\u10da\u10db\u10d8\u10e1 \u10df\u10d0\u10dc\u10e0\u10d4\u10d1\u10d8\u10e1 \u10d2\u10d0\u10db\u10dd\u10e7\u10d4\u10dc\u10d4\u10d1\u10d8\u10d7 \u10d3\u10d0 \u10d9\u10dd\u10da\u10d0\u10d1\u10dd\u10e0\u10d0\u10ea\u10d8\u10e3\u10da \u10e4\u10d8\u10da\u10e2\u10e0\u10d0\u10ea\u10d8\u10d0\u10e1 \u10db\u10dd\u10db\u10ee\u10db\u10d0\u10e0\u10d4\u10d1\u10da\u10d8\u10e1 \u10e8\u10d4\u10e4\u10d0\u10e1\u10d4\u10d1\u10d4\u10d1\u10d8\u10e1 \u10d2\u10d0\u10db\u10dd\u10e7\u10d4\u10dc\u10d4\u10d1\u10d8\u10d7 \u10de\u10d4\u10e0\u10e1\u10dd\u10dc\u10d0\u10da\u10d8\u10d6\u10d4\u10d1\u10e3\u10da\u10d8 \u10e4\u10d8\u10da\u10db\u10d4\u10d1\u10d8\u10e1 \u10e0\u10d4\u10d9\u10dd\u10db\u10d4\u10dc\u10d3\u10d0\u10ea\u10d8\u10d4\u10d1\u10d8\u10e1 \u10e8\u10d4\u10e1\u10d0\u10d7\u10d0\u10d5\u10d0\u10d6\u10d4\u10d1\u10da\u10d0\u10d3.</p>"},{"location":"report/#_2","title":"\u10e1\u10d8\u10e1\u10e2\u10d4\u10db\u10d8\u10e1 \u10d9\u10dd\u10db\u10de\u10dd\u10dc\u10d4\u10dc\u10e2\u10d4\u10d1\u10d8","text":""},{"location":"report/#1","title":"1. \u10db\u10dd\u10dc\u10d0\u10ea\u10d4\u10db\u10d7\u10d0 \u10d3\u10d0\u10db\u10e3\u10e8\u10d0\u10d5\u10d4\u10d1\u10d0","text":"<p>\u10e1\u10d8\u10e1\u10e2\u10d4\u10db\u10d0 \u10d8\u10e2\u10d5\u10d8\u10e0\u10d7\u10d0\u10d5\u10e1 \u10d3\u10d0 \u10ec\u10d8\u10dc\u10d0\u10e1\u10ec\u10d0\u10e0 \u10d0\u10db\u10e3\u10e8\u10d0\u10d5\u10d4\u10d1\u10e1 \u10e4\u10d8\u10da\u10db\u10d4\u10d1\u10d8\u10e1\u10d0 \u10d3\u10d0 \u10e0\u10d4\u10d8\u10e2\u10d8\u10dc\u10d2\u10d8\u10e1 \u10db\u10dd\u10dc\u10d0\u10ea\u10d4\u10db\u10d4\u10d1\u10e1. \u10d8\u10d2\u10d8 \u10d8\u10e7\u10d4\u10dc\u10d4\u10d1\u10e1 TF-IDF-\u10e1 \u10d3\u10d0 \u10d9\u10dd\u10e1\u10d8\u10dc\u10e3\u10e1\u10e3\u10e0 \u10db\u10e1\u10d2\u10d0\u10d5\u10e1\u10d4\u10d1\u10d0\u10e1 \u10e8\u10d8\u10dc\u10d0\u10d0\u10e0\u10e1\u10d6\u10d4 \u10d3\u10d0\u10e4\u10e3\u10eb\u10dc\u10d4\u10d1\u10e3\u10da\u10d8 \u10e0\u10d4\u10d9\u10dd\u10db\u10d4\u10dc\u10d3\u10d0\u10ea\u10d8\u10d4\u10d1\u10d8\u10e1\u10d7\u10d5\u10d8\u10e1.</p>"},{"location":"report/#2","title":"2. \u10db\u10dd\u10d3\u10d4\u10da\u10d8\u10e1 \u10e2\u10e0\u10d4\u10dc\u10d8\u10dc\u10d2\u10d8","text":"<p>\u10d8\u10e5\u10db\u10dc\u10d4\u10d1\u10d0 \u10f0\u10d8\u10d1\u10e0\u10d8\u10d3\u10e3\u10da\u10d8 \u10db\u10dd\u10d3\u10d4\u10da\u10d8, \u10e0\u10dd\u10db\u10d4\u10da\u10d8\u10ea \u10d0\u10d4\u10e0\u10d7\u10d8\u10d0\u10dc\u10d4\u10d1\u10e1: - \u10e8\u10d8\u10dc\u10d0\u10d0\u10e0\u10e1\u10d6\u10d4 \u10d3\u10d0\u10e4\u10e3\u10eb\u10dc\u10d4\u10d1\u10e3\u10da \u10e4\u10d8\u10da\u10e2\u10e0\u10d0\u10ea\u10d8\u10d0\u10e1 - \u10df\u10d0\u10dc\u10e0\u10d8\u10e1 \u10db\u10e1\u10d2\u10d0\u10d5\u10e1\u10d4\u10d1\u10d0\u10e1 - \u10d9\u10dd\u10da\u10d0\u10d1\u10dd\u10e0\u10d0\u10ea\u10d8\u10e3\u10da \u10e4\u10d8\u10da\u10e2\u10e0\u10d0\u10ea\u10d8\u10d0\u10e1 - FAISS-\u10e1 \u10db\u10e1\u10d2\u10d0\u10d5\u10e1\u10d4\u10d1\u10d4\u10d1\u10d8\u10e1 \u10d4\u10e4\u10d4\u10e5\u10e2\u10e3\u10e0\u10d8 \u10eb\u10d8\u10d4\u10d1\u10d8\u10e1\u10d7\u10d5\u10d8\u10e1</p> <p>\u10e1\u10d8\u10e1\u10e2\u10d4\u10db\u10d0 \u10d8\u10dc\u10d0\u10ee\u10d0\u10d5\u10e1 \u10d2\u10d0\u10ec\u10d5\u10e0\u10d7\u10dc\u10d8\u10da \u10db\u10dd\u10d3\u10d4\u10da\u10e1 \u10ee\u10d4\u10da\u10d0\u10ee\u10d0\u10da\u10d8 \u10d2\u10d0\u10db\u10dd\u10e7\u10d4\u10dc\u10d4\u10d1\u10d8\u10e1\u10d7\u10d5\u10d8\u10e1.</p>"},{"location":"report/#3","title":"3. \u10e2\u10d4\u10e1\u10e2\u10d8\u10e0\u10d4\u10d1\u10d0 \u10d3\u10d0 \u10d2\u10d0\u10db\u10d0\u10e0\u10d7\u10d5\u10d0","text":"<p>\u10e1\u10d8\u10e1\u10e2\u10d4\u10db\u10d0 \u10d3\u10d0\u10e1\u10e2\u10e3\u10e0\u10d3\u10d4\u10d1\u10d0 \u10e0\u10d4\u10d9\u10dd\u10db\u10d4\u10dc\u10d3\u10d0\u10ea\u10d8\u10d4\u10d1\u10e1 \u10e1\u10d0\u10e2\u10d4\u10e1\u10e2\u10dd \u10e8\u10d4\u10db\u10d7\u10ee\u10d5\u10d4\u10d5\u10d4\u10d1\u10d8\u10d7 \u10d3\u10d0 \u10e8\u10d4\u10db\u10d3\u10d2\u10dd\u10db \u10e1\u10ec\u10dd\u10e0\u10d3\u10d4\u10d1\u10d0 \u10db\u10dd\u10dc\u10d0\u10ea\u10d4\u10db\u10d7\u10d0 \u10de\u10e0\u10dd\u10d1\u10da\u10d4\u10db\u10d4\u10d1\u10d8, \u10db\u10d0\u10d2\u10d0\u10da\u10d8\u10d7\u10d0\u10d3 \u10e8\u10d4\u10e3\u10e1\u10d0\u10d1\u10d0\u10db\u10dd \u10e4\u10d8\u10da\u10db\u10d4\u10d1\u10d8\u10e1 \u10e1\u10d0\u10d7\u10d0\u10e3\u10e0\u10d4\u10d1\u10d8.</p>"},{"location":"report/#4","title":"4. \u10d5\u10d8\u10d6\u10e3\u10d0\u10da\u10d8\u10d6\u10d0\u10ea\u10d8\u10d0","text":"<p>\u10e1\u10d8\u10e1\u10e2\u10d4\u10db\u10d0 \u10d2\u10d4\u10dc\u10d4\u10e0\u10d8\u10e0\u10d4\u10d1\u10e1 \u10d8\u10dc\u10e4\u10dd\u10e0\u10db\u10d0\u10ea\u10d8\u10d0\u10e1, \u10e0\u10dd\u10d2\u10dd\u10e0\u10d4\u10d1\u10d8\u10ea\u10d0\u10d0: - \u10df\u10d0\u10dc\u10e0\u10d4\u10d1\u10d8\u10e1 \u10d2\u10d0\u10dc\u10d0\u10ec\u10d8\u10da\u10d4\u10d1\u10d0 - \u10e0\u10d4\u10d8\u10e2\u10d8\u10dc\u10d2\u10d8\u10e1 \u10e2\u10d4\u10dc\u10d3\u10d4\u10dc\u10ea\u10d8\u10d4\u10d1\u10d8 - \u10e7\u10d5\u10d4\u10da\u10d0\u10d6\u10d4 \u10db\u10d0\u10e6\u10d0\u10da\u10d8 \u10e0\u10d4\u10d8\u10e2\u10d8\u10dc\u10d2\u10d8\u10e1 \u10db\u10e5\u10dd\u10dc\u10d4 \u10e4\u10d8\u10da\u10db\u10d4\u10d1\u10d8</p>"},{"location":"report/#5","title":"5. \u10db\u10dd\u10db\u10ee\u10db\u10d0\u10e0\u10d4\u10d1\u10da\u10d8\u10e1 \u10d8\u10dc\u10e2\u10d4\u10e0\u10e4\u10d4\u10d8\u10e1\u10d8","text":"<p>Gradio-\u10e1 \u10d2\u10d0\u10db\u10dd\u10e7\u10d4\u10dc\u10d4\u10d1\u10d8\u10d7 \u10e8\u10d4\u10d8\u10e5\u10db\u10dc\u10d0 \u10db\u10d0\u10e0\u10e2\u10d8\u10d5\u10d8 \u10e3\u10e0\u10d7\u10d8\u10d4\u10e0\u10d7\u10e5\u10db\u10d4\u10d3\u10d4\u10d1\u10d8\u10e1 \u10d8\u10dc\u10e2\u10d4\u10e0\u10e4\u10d4\u10d8\u10e1\u10d8. \u10db\u10dd\u10db\u10ee\u10db\u10d0\u10e0\u10d4\u10d1\u10d4\u10da\u10e1 \u10e8\u10d4\u10e3\u10eb\u10da\u10d8\u10d0 \u10e8\u10d4\u10d8\u10e7\u10d5\u10d0\u10dc\u10dd\u10e1 \u10db\u10dd\u10ec\u10dd\u10dc\u10d4\u10d1\u10e3\u10da\u10d8 \u10e4\u10d8\u10da\u10db\u10d8 \u10d3\u10d0 \u10e1\u10d8\u10e1\u10e2\u10d4\u10db\u10d0 \u10e0\u10d4\u10d9\u10dd\u10db\u10d4\u10dc\u10d3\u10d0\u10ea\u10d8\u10d4\u10d1\u10e1 \u10d3\u10d0\u10e3\u10d1\u10e0\u10e3\u10dc\u10d4\u10d1\u10e1.</p>"},{"location":"report/#_3","title":"\u10eb\u10d8\u10e0\u10d8\u10d7\u10d0\u10d3\u10d8 \u10db\u10d8\u10d2\u10dc\u10d4\u10d1\u10d4\u10d1\u10d8","text":""},{"location":"report/#1_1","title":"1. \u10f0\u10d8\u10d1\u10e0\u10d8\u10d3\u10e3\u10da\u10d8 \u10db\u10dd\u10d3\u10d4\u10da\u10d4\u10d1\u10d8 \u10d0\u10ef\u10dd\u10d1\u10d4\u10d1\u10d4\u10dc \u10d4\u10e0\u10d7\u10dd\u10d1\u10da\u10d8\u10d5 \u10db\u10d8\u10d3\u10d2\u10dd\u10db\u10d4\u10d1\u10e1","text":"<ul> <li>\u10e8\u10d8\u10dc\u10d0\u10d0\u10e0\u10e1\u10d6\u10d4 \u10d3\u10d0\u10e4\u10e3\u10eb\u10dc\u10d4\u10d1\u10e3\u10da\u10d8 \u10e4\u10d8\u10da\u10e2\u10e0\u10d0\u10ea\u10d8\u10d0 \u10d9\u10d0\u10e0\u10d2\u10d0\u10d3 \u10db\u10e3\u10e8\u10d0\u10dd\u10d1\u10e1 \u10ea\u10d8\u10d5\u10d8 \u10d3\u10d0\u10ec\u10e7\u10d4\u10d1\u10d8\u10e1 \u10de\u10e0\u10dd\u10d1\u10da\u10d4\u10db\u10d4\u10d1\u10d6\u10d4 (\u10d0\u10ee\u10d0\u10da\u10d8 \u10db\u10dd\u10db\u10ee\u10db\u10d0\u10e0\u10d4\u10d1\u10da\u10d4\u10d1\u10d8), \u10db\u10d0\u10d2\u10e0\u10d0\u10db \u10d0\u10d9\u10da\u10d8\u10d0 \u10de\u10d4\u10e0\u10e1\u10dd\u10dc\u10d0\u10da\u10d8\u10d6\u10d0\u10ea\u10d8\u10d0</li> <li>\u10d9\u10dd\u10da\u10d0\u10d1\u10dd\u10e0\u10d0\u10ea\u10d8\u10e3\u10da\u10d8 \u10e4\u10d8\u10da\u10e2\u10e0\u10d0\u10ea\u10d8\u10d0 \u10d0\u10e3\u10db\u10ef\u10dd\u10d1\u10d4\u10e1\u10d4\u10d1\u10e1 \u10de\u10d4\u10e0\u10e1\u10dd\u10dc\u10d0\u10da\u10d8\u10d6\u10d0\u10ea\u10d8\u10d0\u10e1, \u10db\u10d0\u10d2\u10e0\u10d0\u10db \u10d5\u10d4\u10e0 \u10db\u10e3\u10e8\u10d0\u10dd\u10d1\u10e1, \u10d7\u10e3 \u10db\u10dd\u10db\u10ee\u10db\u10d0\u10e0\u10d4\u10d1\u10da\u10d8\u10e1 \u10db\u10dd\u10dc\u10d0\u10ea\u10d4\u10db\u10d4\u10d1\u10d8 \u10db\u10ec\u10d8\u10e0\u10d8\u10d0</li> <li>\u10dd\u10e0\u10d8\u10d5\u10d4\u10e1 \u10d9\u10dd\u10db\u10d1\u10d8\u10dc\u10d0\u10ea\u10d8\u10d0 (\u10f0\u10d8\u10d1\u10e0\u10d8\u10d3\u10e3\u10da\u10d8 \u10db\u10dd\u10d3\u10d4\u10da\u10d8) \u10e1\u10d0\u10e3\u10d9\u10d4\u10d7\u10d4\u10e1\u10dd \u10e8\u10d4\u10d3\u10d4\u10d2\u10e1 \u10d8\u10eb\u10da\u10d4\u10d5\u10d0</li> </ul>"},{"location":"report/#2_1","title":"2. \u10db\u10dd\u10dc\u10d0\u10ea\u10d4\u10db\u10d7\u10d0 \u10ee\u10d0\u10e0\u10d8\u10e1\u10ee\u10d8 \u10db\u10dc\u10d8\u10e8\u10d5\u10dc\u10d4\u10da\u10dd\u10d5\u10d0\u10dc\u10d8\u10d0","text":"<ul> <li>\u10e4\u10d8\u10da\u10db\u10d4\u10d1\u10d8\u10e1 \u10e1\u10d0\u10d7\u10d0\u10e3\u10e0\u10d4\u10d1\u10d8\u10e1 \u10e8\u10d4\u10e1\u10d0\u10e2\u10e7\u10d5\u10d8\u10e1\u10d4\u10d1\u10d0 \u10e0\u10d7\u10e3\u10da\u10d8 \u10d8\u10e7\u10dd (\u10db\u10d0\u10d2., \"The Dark Knight\" vs. \"Dark Knight, The\")</li> <li>\u10de\u10e0\u10dd\u10d1\u10da\u10d4\u10db\u10d0 \u10d2\u10d0\u10d3\u10d0\u10d8\u10ed\u10e0\u10d0 <code>difflib</code>-\u10d8\u10e1 \u10d2\u10d0\u10db\u10dd\u10e7\u10d4\u10dc\u10d4\u10d1\u10d8\u10d7 \u10e3\u10d6\u10e3\u10e1\u10e2\u10dd \u10e8\u10d4\u10e1\u10d0\u10e2\u10e7\u10d5\u10d8\u10e1\u10d4\u10d1\u10d8\u10e1\u10d7\u10d5\u10d8\u10e1</li> <li>\u10db\u10dd\u10d2\u10d5\u10d8\u10ec\u10d8\u10d0 \u10e0\u10d4\u10d8\u10e2\u10d8\u10dc\u10d2\u10d4\u10d1\u10d8\u10e1 \u10db\u10dd\u10dc\u10d0\u10ea\u10d4\u10db\u10d4\u10d1\u10d8\u10e1 \u10e5\u10d5\u10d4\u10e1\u10d4\u10db\u10de\u10da\u10d8\u10e0\u10d4\u10d1\u10d0 \u10d4\u10e4\u10d4\u10e5\u10e2\u10e3\u10e0\u10dd\u10d1\u10d8\u10e1 \u10d2\u10d0\u10e1\u10d0\u10e3\u10db\u10ef\u10dd\u10d1\u10d4\u10e1\u10d4\u10d1\u10da\u10d0\u10d3</li> </ul>"},{"location":"report/#3_1","title":"3. \u10d3\u10d4\u10d1\u10d0\u10d2\u10d8 \u10d0\u10e3\u10ea\u10d8\u10da\u10d4\u10d1\u10d4\u10da\u10d8\u10d0","text":"<p>\u10d3\u10d0\u10d5\u10d0\u10db\u10d0\u10e2\u10d4\u10d7 \u10d3\u10d4\u10d1\u10d0\u10d2\u10d8\u10e1 \u10da\u10dd\u10d2\u10d4\u10d1\u10d8 (<code>Debug: ...</code>) \u10e0\u10dd\u10db \u10d5\u10d7\u10d5\u10d0\u10da\u10e7\u10e3\u10e0\u10dd\u10d7: - \u10e0\u10dd\u10d2\u10dd\u10e0 \u10d8\u10e7\u10dd \u10db\u10dd\u10db\u10ee\u10db\u10d0\u10e0\u10d4\u10d1\u10da\u10d8\u10e1 \u10e8\u10d4\u10e7\u10d5\u10d0\u10dc\u10d0 \u10d3\u10d0\u10db\u10e3\u10e8\u10d0\u10d5\u10d4\u10d1\u10e3\u10da\u10d8 - \u10e0\u10dd\u10db\u10d4\u10da\u10d8 \u10e4\u10d8\u10da\u10db\u10d4\u10d1\u10d8 \u10d8\u10e7\u10dd \u10e8\u10d4\u10e1\u10d0\u10e2\u10e7\u10d5\u10d8\u10e1\u10d8 - \u10e0\u10d0\u10e2\u10dd\u10db \u10ec\u10d0\u10e0\u10db\u10dd\u10d8\u10e5\u10db\u10dc\u10d0 \u10e0\u10d4\u10d9\u10dd\u10db\u10d4\u10dc\u10d3\u10d0\u10ea\u10d8\u10d4\u10d1\u10d8</p>"},{"location":"report/#4-faiss","title":"4. FAISS \u10d0\u10e9\u10e5\u10d0\u10e0\u10d4\u10d1\u10e1 \u10db\u10e1\u10d2\u10d0\u10d5\u10e1\u10d4\u10d1\u10d8\u10e1 \u10eb\u10d8\u10d4\u10d1\u10d0\u10e1","text":"<p>\u10e8\u10d4\u10d5\u10ea\u10d5\u10d0\u10da\u10d4\u10d7 Scikit-learn-\u10d8\u10e1 <code>cosine_similarity</code> FAISS-\u10d8\u10d7 \u10e3\u10e4\u10e0\u10dd \u10e1\u10ec\u10e0\u10d0\u10e4\u10d8 \u10e3\u10d0\u10ee\u10da\u10dd\u10d4\u10e1\u10d8-\u10db\u10d4\u10d6\u10dd\u10d1\u10da\u10d8\u10e1 \u10eb\u10d8\u10d4\u10d1\u10d8\u10e1\u10d7\u10d5\u10d8\u10e1 \u10d9\u10dd\u10da\u10d0\u10d1\u10dd\u10e0\u10d0\u10ea\u10d8\u10e3\u10da \u10e4\u10d8\u10da\u10e2\u10e0\u10d0\u10ea\u10d8\u10d0\u10e8\u10d8.</p>"},{"location":"report/#5-gradio","title":"5. Gradio \u10d0\u10d0\u10d3\u10d5\u10d8\u10da\u10d4\u10d1\u10e1 \u10d2\u10d0\u10dc\u10d5\u10d8\u10d7\u10d0\u10e0\u10d4\u10d1\u10d0\u10e1","text":"<ul> <li>\u10d0\u10d5\u10d0\u10e8\u10d4\u10dc\u10d4\u10d7 \u10db\u10d0\u10e0\u10e2\u10d8\u10d5\u10d8 UI &lt;50 \u10ee\u10d0\u10d6\u10d8\u10d7 \u10d9\u10dd\u10d3\u10e8\u10d8</li> <li>\u10db\u10dd\u10db\u10ee\u10db\u10d0\u10e0\u10d4\u10d1\u10da\u10d4\u10d1\u10e1 \u10e8\u10d4\u10e3\u10eb\u10da\u10d8\u10d0\u10d7 \u10e8\u10d4\u10d8\u10e7\u10d5\u10d0\u10dc\u10dd\u10dc \u10e4\u10d8\u10da\u10db\u10d4\u10d1\u10d8 \u10d3\u10d0 \u10db\u10d8\u10d8\u10e6\u10dd\u10dc \u10e0\u10d4\u10d9\u10dd\u10db\u10d4\u10dc\u10d3\u10d0\u10ea\u10d8\u10d4\u10d1\u10d8 \u10db\u10e7\u10d8\u10e1\u10d8\u10d4\u10e0\u10d0\u10d3</li> </ul>"},{"location":"report/#_4","title":"\u10e8\u10d4\u10ef\u10d0\u10db\u10d4\u10d1\u10d0","text":"<p>\u10f0\u10d8\u10d1\u10e0\u10d8\u10d3\u10e3\u10da\u10d8 \u10e4\u10d8\u10da\u10db\u10d4\u10d1\u10d8\u10e1 \u10e0\u10d4\u10d9\u10dd\u10db\u10d4\u10dc\u10d3\u10d0\u10ea\u10d8\u10d8\u10e1 \u10e1\u10d8\u10e1\u10e2\u10d4\u10db\u10d0 \u10ec\u10d0\u10e0\u10db\u10d0\u10e2\u10d4\u10d1\u10d8\u10d7 \u10d0\u10d4\u10e0\u10d7\u10d8\u10d0\u10dc\u10d4\u10d1\u10e1 \u10e8\u10d8\u10dc\u10d0\u10d0\u10e0\u10e1\u10d6\u10d4 \u10d3\u10d0\u10e4\u10e3\u10eb\u10dc\u10d4\u10d1\u10e3\u10da \u10d3\u10d0 \u10d9\u10dd\u10da\u10d0\u10d1\u10dd\u10e0\u10d0\u10ea\u10d8\u10e3\u10da \u10e4\u10d8\u10da\u10e2\u10e0\u10d0\u10ea\u10d8\u10d0\u10e1, \u10e0\u10d0\u10ea \u10e3\u10d6\u10e0\u10e3\u10dc\u10d5\u10d4\u10da\u10e7\u10dd\u10e4\u10e1 \u10e0\u10dd\u10d2\u10dd\u10e0\u10ea \u10d0\u10ee\u10d0\u10da\u10d8 \u10db\u10dd\u10db\u10ee\u10db\u10d0\u10e0\u10d4\u10d1\u10da\u10d4\u10d1\u10d8\u10e1, \u10d8\u10e1\u10d4 \u10d2\u10d0\u10db\u10dd\u10ea\u10d3\u10d8\u10da\u10d8 \u10db\u10dd\u10db\u10ee\u10db\u10d0\u10e0\u10d4\u10d1\u10da\u10d4\u10d1\u10d8\u10e1 \u10db\u10d0\u10e6\u10d0\u10da\u10d8 \u10ee\u10d0\u10e0\u10d8\u10e1\u10ee\u10d8\u10e1 \u10e0\u10d4\u10d9\u10dd\u10db\u10d4\u10dc\u10d3\u10d0\u10ea\u10d8\u10d4\u10d1\u10e1. \u10e1\u10d8\u10e1\u10e2\u10d4\u10db\u10d0 \u10dd\u10de\u10e2\u10d8\u10db\u10d8\u10d6\u10d4\u10d1\u10e3\u10da\u10d8\u10d0 \u10d4\u10e4\u10d4\u10e5\u10e2\u10e3\u10e0\u10dd\u10d1\u10d8\u10e1\u10d7\u10d5\u10d8\u10e1 \u10d3\u10d0 \u10db\u10d0\u10e0\u10e2\u10d8\u10d5\u10d8\u10d0 \u10d2\u10d0\u10db\u10dd\u10e7\u10d4\u10dc\u10d4\u10d1\u10d8\u10e1\u10d7\u10d5\u10d8\u10e1.</p>"},{"location":"report/#movie-recommendation-system-project-report-and-overview_1","title":"Movie Recommendation System: Project Report and Overview","text":"<p>We developed a hybrid movie recommendation system that combines content-based filtering using movie genres and collaborative filtering using user ratings to provide personalized movie recommendations.</p>"},{"location":"report/#system-components","title":"System Components","text":""},{"location":"report/#1-data-processing","title":"1. Data Processing","text":"<p>The system loads and preprocesses movie and rating data. It uses TF-IDF and cosine similarity for content-based recommendations.</p>"},{"location":"report/#2-model-training","title":"2. Model Training","text":"<p>A hybrid model is created that combines: - Content-based filtering - Genre similarity - Collaborative filtering - FAISS for efficient similarity search</p> <p>The system saves the trained model for reuse.</p>"},{"location":"report/#3-testing-and-debugging","title":"3. Testing and Debugging","text":"<p>The system validates recommendations with test cases and subsequently fixes data issues, such as inconsistent movie titles.</p>"},{"location":"report/#4-visualization","title":"4. Visualization","text":"<p>The system generates information such as: - Genre distribution - Rating trends - Highest-rated movies</p>"},{"location":"report/#5-user-interface","title":"5. User Interface","text":"<p>A simple interaction interface was created using Gradio. Users can input their favorite movies and the system returns recommendations.</p>"},{"location":"report/#key-findings","title":"Key Findings","text":""},{"location":"report/#1-hybrid-models-outperform-individual-approaches","title":"1. Hybrid Models Outperform Individual Approaches","text":"<ul> <li>Content-based filtering works well for cold start problems (new users) but lacks personalization</li> <li>Collaborative filtering improves personalization but fails when user data is sparse</li> <li>Combining both (hybrid model) provides the best results</li> </ul>"},{"location":"report/#2-data-quality-is-critical","title":"2. Data Quality is Critical","text":"<ul> <li>Movie title matching was challenging (e.g., \"The Dark Knight\" vs. \"Dark Knight, The\")</li> <li>The problem was solved using <code>difflib</code> for fuzzy matching</li> <li>We had to subsample rating data to improve efficiency</li> </ul>"},{"location":"report/#3-debugging-is-essential","title":"3. Debugging is Essential","text":"<p>We added debug logs (<code>Debug: ...</code>) to monitor: - How user input was processed - Which movies were matched - Why recommendations were generated</p>"},{"location":"report/#4-faiss-accelerates-similarity-search","title":"4. FAISS Accelerates Similarity Search","text":"<p>We replaced Scikit-learn's <code>cosine_similarity</code> with FAISS for faster nearest-neighbor search in collaborative filtering.</p>"},{"location":"report/#5-gradio-simplifies-development","title":"5. Gradio Simplifies Development","text":"<ul> <li>Built a simple UI in &lt;50 lines of code</li> <li>Users can input movies and receive recommendations instantly</li> </ul>"},{"location":"report/#conclusion","title":"Conclusion","text":"<p>The hybrid movie recommendation system successfully combines content-based and collaborative filtering, ensuring high-quality recommendations for both new and experienced users. The system is optimized for efficiency and easy to use.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"usage/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Note: this model creates sparse matrixes, and can be heavy for ram!</p> <p>Recommended ram for deployment system is at least 32GB!</p> <p>Before running the Personal Movie Recommender, ensure you have the following installed:</p> <ul> <li>\ud83d\udcbb WSL (Windows Subsystem for Linux) this is necessary for faiss library. (only works on linux &amp; macos)</li> <li>\ud83d\udc0d Python 3.8+ (Nix shell provides Python 3.13)</li> <li> <p>\ud83d\udce6 Required packages:</p> </li> <li> <p><code>pip</code> \u2014 Python package installer</p> </li> <li><code>pandas</code> \u2014 for data manipulation and analysis</li> <li><code>matplotlib</code> \u2014 for plotting and visualizations</li> <li><code>seaborn</code> \u2014 statistical data visualization based on matplotlib</li> <li><code>scikit-learn</code> \u2014 for similarity calculations and machine learning</li> <li><code>gradio</code> \u2014 for the interactive web interface</li> <li><code>faiss</code> \u2014 efficient similarity search library</li> </ul>"},{"location":"usage/#installation","title":"\ud83d\udd27 Installation","text":"<ol> <li> <p>\ud83d\udce5 Clone the repository: <pre><code>git clone https://github.com/Gurjaka/Personal-movie-recommendation-model.git\ncd Personal-movie-recommendation-model\n</code></pre></p> </li> <li> <p>\u2699\ufe0f Install dependencies:</p> </li> </ol> <p>Using pip: <code>pip install -r requirements.txt</code></p> <p>Or if you use Nix flakes: <code>nix develop</code></p> <ol> <li>\ud83d\udcca Prepare your data:</li> </ol> <p>Download the required datasets and place them in the <code>data/</code> directory:    - <code>movies.csv</code> - movie metadata (title, genres, year, etc.)    - <code>ratings.csv</code> - user ratings data</p> <p>You can obtain these datasets from Kaggle: Movie Recommendation System Dataset.</p>"},{"location":"usage/#usage","title":"\ud83c\udfaf Usage","text":""},{"location":"usage/#1-train-the-recommendation-model","title":"1. \ud83e\udde0 Train the Recommendation Model","text":"<p>First, train the hybrid recommendation model: <code>python src/train.py</code></p> <p>This will: - \ud83d\udcd6 Load and preprocess the movie and ratings data - \ud83d\udd27 Build collaborative filtering and content-based models - \ud83d\udcbe Save the trained model as <code>hybrid_model.joblib</code></p>"},{"location":"usage/#2-run-the-data-debugger","title":"2. \ud83d\udee0\ufe0f Run the Data Debugger","text":"<p>Next let's run debugger to inspect the dataset: <code>python src/data_debug.py</code></p> <p>This script will help you inspect and verify your dataset. It will: - \ud83d\udcd0 Print the shape (rows \u00d7 columns) of the raw movies.csv and ratings.csv - \ud83d\udcdd Show the first 5 entries from each dataset - \ud83e\uddfe List all columns in the movies.csv file - \ud83d\udd04 Preprocess and clean the movie data - \ud83d\udcca Display genre distribution and perform basic genre analysis</p> <p>Use this to ensure your dataset is correctly formatted and loaded before training.</p>"},{"location":"usage/#3-run-a-basic-test-before-deployment","title":"3. \u2705 Run a Basic Test Before Deployment","text":"<p>Now, let's confirm the model works properly before launching the app: <code>python src/simple_test.py</code></p> <p>This script performs a sanity check to confirm the model is functioning. It will: - \ud83e\udde0 Load the model and required similarity data - \u2699\ufe0f Generate the cosine_sim.npy file (if it doesn't already exist) \u2014 this precomputed similarity matrix helps reduce RAM usage and speed up recommendations - \ud83c\udfac Run the model on a few predefined test cases - \ud83d\udda8\ufe0f Print out sample recommendations to the terminal</p> <p>Run this after training to confirm everything works as expected before launching the interface.</p>"},{"location":"usage/#4-launch-the-web-interface","title":"4. \ud83c\udf10 Launch the Web Interface","text":"<p>Start the Gradio web application: <code>python src/main.py</code></p> <p>This will: - \ud83d\ude80 Load the trained model - \ud83d\udda5\ufe0f Launch an interactive web interface - \ud83c\udfad Allow you to input preferences and get personalized recommendations</p> <p>The interface will be available at <code>http://localhost:7860</code> by default.</p>"},{"location":"usage/#5-generate-visualizations-optional","title":"5. \ud83d\udcc8 Generate Visualizations (Optional)","text":"<p>Create data visualizations and analysis charts:</p> <pre><code>python src/visualize.py\n</code></pre> <p>This generates various plots showing: - \ud83d\udcca Rating distributions - \ud83c\udfac Genre popularity - \ud83d\udc65 User behavior patterns - \ud83c\udfaf Model performance metrics</p>"},{"location":"usage/#development-testing","title":"\ud83d\udee0\ufe0f Development &amp; Testing","text":"<p>The <code>src/</code> directory contains additional utility scripts for development:</p> <ul> <li><code>test.py</code> - \ud83e\uddea unit tests for core functionality</li> <li><code>utils.py</code> - \ud83d\udd27 helper functions for data processing</li> <li>Various debugging scripts for testing specific components</li> </ul> <p>To run tests: <pre><code>python src/test.py\n</code></pre></p>"},{"location":"usage/#troubleshooting","title":"\ud83d\udd27 Troubleshooting","text":"<ul> <li>\ud83d\udcc1 Missing data files: Ensure <code>movies.csv</code> and <code>ratings.csv</code> are in the <code>data/</code> directory</li> <li>\ud83d\udc0f Memory issues: For large datasets, consider using data sampling or increasing system memory</li> <li>\ud83d\udd0c Port conflicts: If port 7860 is occupied, Gradio will automatically use the next available port</li> </ul>"},{"location":"usage/#next-steps","title":"\ud83c\udfaf Next Steps","text":"<ul> <li>\ud83d\udcda Explore the API documentation for programmatic access</li> <li>\ud83d\udcca Check out the visualization outputs to understand your data better</li> <li>\ud83d\udd2c Modify the model parameters in <code>train.py</code> to experiment with different approaches</li> </ul>"},{"location":"reference/main/","title":"Main File","text":""},{"location":"reference/main/#src.main.format_recommendations","title":"<code>format_recommendations(df)</code>","text":"<p>Format movie recommendations as a user-friendly text display.</p> <p>This function converts a DataFrame of movie recommendations into a visually appealing text format with emojis and clear formatting. Designed for display in the Gradio interface output.</p> Example <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'title': ['The Matrix', 'Inception'],\n...     'genres': [['Action', 'Sci-Fi'], ['Action', 'Thriller']]\n... })\n&gt;&gt;&gt; print(format_recommendations(df))\n\ud83c\udfac The Matrix\n   \ud83d\udcc2 Genres: Action, Sci-Fi\n\n\ud83c\udfac Inception\n   \ud83d\udcc2 Genres: Action, Thriller\n</code></pre> Source code in <code>src/main.py</code> <pre><code>def format_recommendations(df: pd.DataFrame) -&gt; str:\n    \"\"\"\n    Format movie recommendations as a user-friendly text display.\n\n    This function converts a DataFrame of movie recommendations into a visually\n    appealing text format with emojis and clear formatting. Designed for display\n    in the Gradio interface output.\n\n    Example:\n        ```\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     'title': ['The Matrix', 'Inception'],\n        ...     'genres': [['Action', 'Sci-Fi'], ['Action', 'Thriller']]\n        ... })\n        &gt;&gt;&gt; print(format_recommendations(df))\n        \ud83c\udfac The Matrix\n           \ud83d\udcc2 Genres: Action, Sci-Fi\n\n        \ud83c\udfac Inception\n           \ud83d\udcc2 Genres: Action, Thriller\n        ```\n    \"\"\"\n    if df.empty:\n        return \"No recommendations found.\"\n\n    lines = []\n    for _, row in df.iterrows():\n        title = row['title']\n        genres = ', '.join(row['genres']) if isinstance(row['genres'], list) else row['genres']\n        lines.append(f\"\ud83c\udfac {title}\\n   \ud83d\udcc2 Genres: {genres}\")\n    return '\\n\\n'.join(lines)\n</code></pre>"},{"location":"reference/main/#src.main.format_recommendations_markdown","title":"<code>format_recommendations_markdown(df)</code>","text":"<p>Format movie recommendations as a Markdown table.</p> <p>This function converts a DataFrame of movie recommendations into a formatted Markdown table with movie titles and genres. Useful for displaying recommendations in Markdown-compatible interfaces or documentation.</p> Example <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'title': ['The Matrix', 'Inception'],\n...     'genres': [['Action', 'Sci-Fi'], ['Action', 'Thriller']]\n... })\n&gt;&gt;&gt; print(format_recommendations_markdown(df))\n| Title | Genres |\n|-------|--------|\n| The Matrix | Action, Sci-Fi |\n| Inception | Action, Thriller |\n</code></pre> Source code in <code>src/main.py</code> <pre><code>def format_recommendations_markdown(df: pd.DataFrame) -&gt; str:\n    \"\"\"\n    Format movie recommendations as a Markdown table.\n\n    This function converts a DataFrame of movie recommendations into a formatted\n    Markdown table with movie titles and genres. Useful for displaying recommendations\n    in Markdown-compatible interfaces or documentation.\n\n    Example:\n        ```\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     'title': ['The Matrix', 'Inception'],\n        ...     'genres': [['Action', 'Sci-Fi'], ['Action', 'Thriller']]\n        ... })\n        &gt;&gt;&gt; print(format_recommendations_markdown(df))\n        | Title | Genres |\n        |-------|--------|\n        | The Matrix | Action, Sci-Fi |\n        | Inception | Action, Thriller |\n        ```\n    \"\"\"\n    if df.empty:\n        return \"No recommendations found.\"\n\n    lines = [\"| Title | Genres |\", \"|-------|--------|\"]\n    for _, row in df.iterrows():\n        title = row['title']\n        genres = ', '.join(row['genres']) if isinstance(row['genres'], list) else row['genres']\n        lines.append(f\"| {title} | {genres} |\")\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"reference/main/#src.main.recommend_movies","title":"<code>recommend_movies(user_input)</code>","text":"<p>Generate movie recommendations based on user input.</p> <p>This is the main function that powers the movie recommendation system. It parses user input, creates a rating profile, and generates recommendations using either the hybrid model (if available) or content-based filtering.</p> Source code in <code>src/main.py</code> <pre><code>def recommend_movies(user_input: str):\n    \"\"\"\n    Generate movie recommendations based on user input.\n\n    This is the main function that powers the movie recommendation system.\n    It parses user input, creates a rating profile, and generates recommendations\n    using either the hybrid model (if available) or content-based filtering.\n    \"\"\"\n    print(f\"\\n\ud83d\udd0d DEBUG: User input: '{user_input}'\")\n\n    # Parse input: \"Movie Title, Movie Title, Movie Title\"\n    user_ratings = {}\n    movie_titles = [title.strip() for title in user_input.split(',') if title.strip()]\n\n    if not movie_titles:\n        return \"Please enter at least one movie title\"\n\n    print(f\"\ud83d\udd0d DEBUG: Parsed movie titles: {movie_titles}\")\n\n    # Assign default rating of 4.0 to all movies (assuming user likes them)\n    for title in movie_titles:\n        user_ratings[title] = 4.0\n\n    print(f\"\ud83d\udd0d DEBUG: User ratings dict: {user_ratings}\")\n    print(f\"\ud83d\udd0d DEBUG: Model loaded: {model_loaded}\")\n\n    # Use hybrid model if available, else content-based\n    if model_loaded:\n        print(\"\ud83d\udd0d DEBUG: Using hybrid model\")\n        recommendations = hybrid_model.hybrid_recommend(user_ratings)\n        print(f\"\ud83d\udd0d DEBUG: Hybrid recommendations shape: {recommendations.shape}\")\n        print(f\"\ud83d\udd0d DEBUG: Hybrid recommendations:\\n{recommendations}\")\n    else:\n        print(\"\ud83d\udd0d DEBUG: Using content-based model\")\n        content_model = ContentModel(movies)\n        recommendations = content_model.content_recommendations(user_ratings)\n        print(f\"\ud83d\udd0d DEBUG: Content recommendations shape: {recommendations.shape}\")\n        print(f\"\ud83d\udd0d DEBUG: Content recommendations:\\n{recommendations}\")\n\n    # Format output\n    if recommendations.empty:\n        return \"No recommendations found. Please check if movie titles are correct.\"\n\n    result = format_recommendations(recommendations)\n    print(f\"\ud83d\udd0d DEBUG: Final formatted result:\\n{result}\")\n    return result\n</code></pre>"},{"location":"reference/main/#src.main.test_recommendations","title":"<code>test_recommendations()</code>","text":"<p>Test the recommendation system with predefined movie inputs.</p> <p>This function runs automated tests on the recommendation system using different genres and movie combinations to verify functionality. Useful for debugging and ensuring the system works correctly before deployment.</p> Source code in <code>src/main.py</code> <pre><code>def test_recommendations():\n    \"\"\"\n    Test the recommendation system with predefined movie inputs.\n\n    This function runs automated tests on the recommendation system using\n    different genres and movie combinations to verify functionality.\n    Useful for debugging and ensuring the system works correctly before\n    deployment.\n    \"\"\"\n    test_inputs = [\n        \"The Dark Knight, Inception, Interstellar\",\n        \"Toy Story, Finding Nemo, Shrek\", \n        \"The Shawshank Redemption, Forrest Gump, Pulp Fiction\"\n    ]\n\n    for i, test_input in enumerate(test_inputs):\n        print(f\"\\n{'='*50}\")\n        print(f\"TEST {i+1}: {test_input}\")\n        print(f\"{'='*50}\")\n        result = recommend_movies(test_input)\n        print(f\"RESULT:\\n{result}\")\n</code></pre>"},{"location":"reference/train/","title":"Model Training Module","text":""},{"location":"reference/train/#src.train.HybridModel","title":"<code>HybridModel</code>","text":"<p>A hybrid recommendation system combining content-based and collaborative filtering.</p> <p>This class implements a hybrid approach that leverages both content-based filtering (using movie genres) and collaborative filtering (using user-item interactions). It uses FAISS for efficient similarity search in the collaborative filtering component and combines recommendations from both approaches.</p> Source code in <code>src/train.py</code> <pre><code>class HybridModel:\n    \"\"\"\n    A hybrid recommendation system combining content-based and collaborative filtering.\n\n    This class implements a hybrid approach that leverages both content-based filtering\n    (using movie genres) and collaborative filtering (using user-item interactions).\n    It uses FAISS for efficient similarity search in the collaborative filtering component\n    and combines recommendations from both approaches.\n    \"\"\"\n\n    def __init__(self, movies: pd.DataFrame, ratings: pd.DataFrame):\n        \"\"\"\n        Initialize the hybrid recommendation model.\n\n        Sets up the hybrid model by creating sparse matrices for collaborative filtering,\n        training the FAISS index, and preparing all necessary mappings.\n        \"\"\"\n        self.movies = movies\n        self.ratings = ratings\n        self.sparse_matrix, self.user_mapper, self.movie_mapper = self._create_sparse_matrix()\n        self.model = self._train_model()\n\n    def _create_sparse_matrix(self):\n        \"\"\"\n        Create a sparse user-item rating matrix with ID mappings.\n\n        This private method processes the ratings data to create:\n        1. A sparse matrix representation of user-item interactions\n        2. Mappings from user/movie IDs to matrix indices\n        \"\"\"\n        # Create mappings\n        user_ids = self.ratings['userId'].unique()\n        movie_ids = self.ratings['movieId'].unique()\n\n        user_mapper = {user: idx for idx, user in enumerate(user_ids)}\n        movie_mapper = {movie: idx for idx, movie in enumerate(movie_ids)}\n\n        # Convert to sparse matrix\n        rows = [user_mapper[user] for user in self.ratings['userId']]\n        cols = [movie_mapper[movie] for movie in self.ratings['movieId']]\n\n        sparse_matrix = csr_matrix(\n            (self.ratings['rating'], (rows, cols)),\n            shape=(len(user_mapper), len(movie_mapper))\n        )\n\n        return sparse_matrix, user_mapper, movie_mapper\n\n    def _train_model(self):\n        \"\"\"\n        Train the FAISS index for collaborative filtering similarity search.\n\n        This private method prepares the collaborative filtering component by:\n        1. Converting sparse matrix to dense format\n        2. Normalizing vectors using L2 normalization\n        3. Creating and training a FAISS index for fast similarity search\n        \"\"\"\n        dense_matrix = self.sparse_matrix.toarray().astype('float32')\n        faiss.normalize_L2(dense_matrix)\n        index = faiss.IndexFlatIP(dense_matrix.shape[1])\n        index.add(dense_matrix)\n\n        return index\n\n    def find_closest_title(self, input_title: str) -&gt; str | None:\n        \"\"\"\n        Find the closest matching movie title using fuzzy string matching.\n\n        This method handles typos and variations in movie titles by finding\n        the most similar title in the movies database using sequence matching.\n        \"\"\"\n        titles = self.movies['title'].tolist()\n        matches = difflib.get_close_matches(input_title, titles, n=1, cutoff=0.6)\n        return matches[0] if matches else None\n\n    def hybrid_recommend(self, user_ratings: dict, content_weight=0.4, top_n=5) -&gt; pd.DataFrame:\n        \"\"\"\n        Generate hybrid recommendations combining content-based and collaborative filtering.\n\n        This method implements a hybrid recommendation approach that:\n        1. Generates content-based recommendations using movie genres\n        2. Creates collaborative filtering recommendations using user similarity\n        3. Combines both approaches to provide diverse, high-quality recommendations\n        4. Handles fuzzy matching for movie titles to improve usability\n        \"\"\"\n        print(f\"Debug: Input user_ratings: {user_ratings}\")\n\n        # Content-based recommendations\n        content_model = ContentModel(self.movies)\n        content_recs = content_model.content_recommendations(user_ratings, top_n*2)\n        print(f\"Debug: Content recommendations: {content_recs['title'].tolist()}\")\n\n        # Collaborative filtering\n        user_profile = np.zeros(self.sparse_matrix.shape[1], dtype='float32')\n        matched_titles = {}\n\n        for title, rating in user_ratings.items():\n            matched_title = self.find_closest_title(title)\n            if matched_title:\n                matched_titles[title] = matched_title\n                movie_id = self.movies[self.movies['title'] == matched_title]['movieId'].values[0]\n                if movie_id in self.movie_mapper:\n                    movie_idx = self.movie_mapper[movie_id]\n                    user_profile[movie_idx] = rating\n                    print(f\"Debug: {title} \u2192 {matched_title} (movie_id: {movie_id}, idx: {movie_idx})\")\n\n        collab_movies = []\n        if np.count_nonzero(user_profile) == 0:\n            print(\"\u26a0\ufe0f Warning: No matched titles found in user input!\")\n        else:\n            faiss.normalize_L2(user_profile.reshape(1, -1))\n            _, indices = self.model.search(user_profile.reshape(1, -1), top_n * 3)\n            print(f\"Debug: Collaborative indices: {indices[0]}\")\n\n            # Get movie IDs from indices\n            inv_movie_mapper = {v: k for k, v in self.movie_mapper.items()}\n            for idx in indices[0]:\n                movie_id = inv_movie_mapper.get(idx)\n                if movie_id:\n                    movie_row = self.movies[self.movies['movieId'] == movie_id]\n                    if not movie_row.empty:\n                        title = movie_row['title'].values[0]\n                        # Don't recommend movies the user already rated\n                        if title not in user_ratings.keys() and title not in matched_titles.values():\n                            collab_movies.append(title)\n\n        print(f\"Debug: Collaborative movies: {collab_movies}\")\n\n        # Combine results - this was the main bug!\n        all_recommendations = set()\n\n        # Add content-based recommendations\n        for title in content_recs['title'].tolist():\n            if title not in user_ratings.keys() and title not in matched_titles.values():\n                all_recommendations.add(title)\n\n        # Add collaborative recommendations\n        for title in collab_movies:\n            all_recommendations.add(title)\n\n        # Convert to list and get top N\n        final_recommendations = list(all_recommendations)[:top_n]\n        print(f\"Debug: Final recommendations: {final_recommendations}\")\n\n        # Return properly formatted DataFrame\n        if final_recommendations:\n            result_df = self.movies[self.movies['title'].isin(final_recommendations)][['title', 'genres']].head(top_n)\n            return result_df\n        else:\n            return pd.DataFrame(columns=['title', 'genres'])\n</code></pre>"},{"location":"reference/train/#src.train.HybridModel.__init__","title":"<code>__init__(movies, ratings)</code>","text":"<p>Initialize the hybrid recommendation model.</p> <p>Sets up the hybrid model by creating sparse matrices for collaborative filtering, training the FAISS index, and preparing all necessary mappings.</p> Source code in <code>src/train.py</code> <pre><code>def __init__(self, movies: pd.DataFrame, ratings: pd.DataFrame):\n    \"\"\"\n    Initialize the hybrid recommendation model.\n\n    Sets up the hybrid model by creating sparse matrices for collaborative filtering,\n    training the FAISS index, and preparing all necessary mappings.\n    \"\"\"\n    self.movies = movies\n    self.ratings = ratings\n    self.sparse_matrix, self.user_mapper, self.movie_mapper = self._create_sparse_matrix()\n    self.model = self._train_model()\n</code></pre>"},{"location":"reference/train/#src.train.HybridModel.find_closest_title","title":"<code>find_closest_title(input_title)</code>","text":"<p>Find the closest matching movie title using fuzzy string matching.</p> <p>This method handles typos and variations in movie titles by finding the most similar title in the movies database using sequence matching.</p> Source code in <code>src/train.py</code> <pre><code>def find_closest_title(self, input_title: str) -&gt; str | None:\n    \"\"\"\n    Find the closest matching movie title using fuzzy string matching.\n\n    This method handles typos and variations in movie titles by finding\n    the most similar title in the movies database using sequence matching.\n    \"\"\"\n    titles = self.movies['title'].tolist()\n    matches = difflib.get_close_matches(input_title, titles, n=1, cutoff=0.6)\n    return matches[0] if matches else None\n</code></pre>"},{"location":"reference/train/#src.train.HybridModel.hybrid_recommend","title":"<code>hybrid_recommend(user_ratings, content_weight=0.4, top_n=5)</code>","text":"<p>Generate hybrid recommendations combining content-based and collaborative filtering.</p> <p>This method implements a hybrid recommendation approach that: 1. Generates content-based recommendations using movie genres 2. Creates collaborative filtering recommendations using user similarity 3. Combines both approaches to provide diverse, high-quality recommendations 4. Handles fuzzy matching for movie titles to improve usability</p> Source code in <code>src/train.py</code> <pre><code>def hybrid_recommend(self, user_ratings: dict, content_weight=0.4, top_n=5) -&gt; pd.DataFrame:\n    \"\"\"\n    Generate hybrid recommendations combining content-based and collaborative filtering.\n\n    This method implements a hybrid recommendation approach that:\n    1. Generates content-based recommendations using movie genres\n    2. Creates collaborative filtering recommendations using user similarity\n    3. Combines both approaches to provide diverse, high-quality recommendations\n    4. Handles fuzzy matching for movie titles to improve usability\n    \"\"\"\n    print(f\"Debug: Input user_ratings: {user_ratings}\")\n\n    # Content-based recommendations\n    content_model = ContentModel(self.movies)\n    content_recs = content_model.content_recommendations(user_ratings, top_n*2)\n    print(f\"Debug: Content recommendations: {content_recs['title'].tolist()}\")\n\n    # Collaborative filtering\n    user_profile = np.zeros(self.sparse_matrix.shape[1], dtype='float32')\n    matched_titles = {}\n\n    for title, rating in user_ratings.items():\n        matched_title = self.find_closest_title(title)\n        if matched_title:\n            matched_titles[title] = matched_title\n            movie_id = self.movies[self.movies['title'] == matched_title]['movieId'].values[0]\n            if movie_id in self.movie_mapper:\n                movie_idx = self.movie_mapper[movie_id]\n                user_profile[movie_idx] = rating\n                print(f\"Debug: {title} \u2192 {matched_title} (movie_id: {movie_id}, idx: {movie_idx})\")\n\n    collab_movies = []\n    if np.count_nonzero(user_profile) == 0:\n        print(\"\u26a0\ufe0f Warning: No matched titles found in user input!\")\n    else:\n        faiss.normalize_L2(user_profile.reshape(1, -1))\n        _, indices = self.model.search(user_profile.reshape(1, -1), top_n * 3)\n        print(f\"Debug: Collaborative indices: {indices[0]}\")\n\n        # Get movie IDs from indices\n        inv_movie_mapper = {v: k for k, v in self.movie_mapper.items()}\n        for idx in indices[0]:\n            movie_id = inv_movie_mapper.get(idx)\n            if movie_id:\n                movie_row = self.movies[self.movies['movieId'] == movie_id]\n                if not movie_row.empty:\n                    title = movie_row['title'].values[0]\n                    # Don't recommend movies the user already rated\n                    if title not in user_ratings.keys() and title not in matched_titles.values():\n                        collab_movies.append(title)\n\n    print(f\"Debug: Collaborative movies: {collab_movies}\")\n\n    # Combine results - this was the main bug!\n    all_recommendations = set()\n\n    # Add content-based recommendations\n    for title in content_recs['title'].tolist():\n        if title not in user_ratings.keys() and title not in matched_titles.values():\n            all_recommendations.add(title)\n\n    # Add collaborative recommendations\n    for title in collab_movies:\n        all_recommendations.add(title)\n\n    # Convert to list and get top N\n    final_recommendations = list(all_recommendations)[:top_n]\n    print(f\"Debug: Final recommendations: {final_recommendations}\")\n\n    # Return properly formatted DataFrame\n    if final_recommendations:\n        result_df = self.movies[self.movies['title'].isin(final_recommendations)][['title', 'genres']].head(top_n)\n        return result_df\n    else:\n        return pd.DataFrame(columns=['title', 'genres'])\n</code></pre>"},{"location":"reference/train/#src.train.load_hybrid_model","title":"<code>load_hybrid_model()</code>","text":"<p>Load a pre-trained hybrid recommendation model from disk.</p> <p>This helper function loads a previously saved hybrid model using joblib, ensuring proper class reference resolution for successful deserialization.</p> Source code in <code>src/train.py</code> <pre><code>def load_hybrid_model():\n    \"\"\"\n    Load a pre-trained hybrid recommendation model from disk.\n\n    This helper function loads a previously saved hybrid model using joblib,\n    ensuring proper class reference resolution for successful deserialization.\n    \"\"\"\n    import __main__\n    __main__.HybridModel = HybridModel\n    return joblib.load(\"hybrid_model.joblib\")\n</code></pre>"},{"location":"reference/train/#src.train.train_model","title":"<code>train_model()</code>","text":"<p>Train and save the hybrid recommendation model.</p> <p>This function orchestrates the complete model training process: 1. Loads movie and rating data from CSV files 2. Applies data preprocessing and downsampling for performance 3. Trains the hybrid model combining content-based and collaborative filtering 4. Saves the trained model to disk using joblib</p> <p>The function performs data downsampling to improve training speed and memory usage by selecting the top 20,000 most active users and top 10,000 most rated movies.</p> Source code in <code>src/train.py</code> <pre><code>def train_model():\n    \"\"\"\n    Train and save the hybrid recommendation model.\n\n    This function orchestrates the complete model training process:\n    1. Loads movie and rating data from CSV files\n    2. Applies data preprocessing and downsampling for performance\n    3. Trains the hybrid model combining content-based and collaborative filtering\n    4. Saves the trained model to disk using joblib\n\n    The function performs data downsampling to improve training speed and memory usage\n    by selecting the top 20,000 most active users and top 10,000 most rated movies.\n    \"\"\"\n    # Initialize data handler\n    data_handler = DataHandler(\"data/\")\n\n    # Load and preprocess data\n    movies, ratings = data_handler.load_data(\"movies.csv\", \"ratings.csv\")\n\n    # downsample\n    top_users = ratings['userId'].value_counts().head(20000).index\n    top_movies = ratings['movieId'].value_counts().head(10000).index\n    ratings = ratings[ratings['userId'].isin(top_users) &amp; ratings['movieId'].isin(top_movies)]\n\n    # Train hybrid model\n    movies = data_handler.preprocess_movies(movies)\n    model = HybridModel(movies, ratings)\n\n    # Save model with proper module reference\n    import __main__\n    __main__.HybridModel = HybridModel\n    joblib.dump(model, \"hybrid_model.joblib\")\n    print(\"Hybrid model trained and saved!\")\n</code></pre>"},{"location":"reference/utils/","title":"Utils Module","text":""},{"location":"reference/utils/#src.utils.ContentModel","title":"<code>ContentModel</code>","text":"<p>A content-based recommendation model using TF-IDF and cosine similarity.</p> <p>This class implements a content-based filtering approach for movie recommendations. It uses TF-IDF vectorization on movie genres and computes cosine similarity to find movies similar to those rated by users.</p> Source code in <code>src/utils.py</code> <pre><code>class ContentModel:\n    \"\"\"\n    A content-based recommendation model using TF-IDF and cosine similarity.\n\n    This class implements a content-based filtering approach for movie recommendations.\n    It uses TF-IDF vectorization on movie genres and computes cosine similarity\n    to find movies similar to those rated by users.\n    \"\"\"\n\n    def __init__(self, movies: pd.DataFrame):\n        \"\"\"\n        Initialize the ContentModel with movie data.\n\n        This constructor sets up the TF-IDF vectorizer, computes the similarity matrix,\n        and creates necessary mappings for efficient recommendation generation.\n        \"\"\"\n        self.movies = movies\n        self.tfidf = TfidfVectorizer(stop_words='english')\n\n        # Create genre strings for TF-IDF\n        genre_strings = movies['genres'].apply(lambda x: ' '.join(x) if isinstance(x, list) else str(x))\n        self.tfidf_matrix = self.tfidf.fit_transform(genre_strings)\n\n        # Precompute cosine similarity matrix if not exists\n        if os.path.exists(\"cosine_sim.npy\"):\n            self.cosine_sim = np.load(\"cosine_sim.npy\")\n        else:\n            self.cosine_sim = cosine_similarity(self.tfidf_matrix, self.tfidf_matrix)\n            np.save(\"cosine_sim.npy\", self.cosine_sim)\n\n        # Create title to index mapping\n        self.indices = pd.Series(movies.index, index=movies['title']).drop_duplicates()\n\n    def find_closest_title(self, input_title: str) -&gt; str | None:\n        \"\"\"\n        Find the closest matching movie title in the dataset using fuzzy matching.\n\n        This method uses difflib to find the most similar movie title to the user's\n        input, helping to handle typos and variations in movie titles.\n        \"\"\"\n        titles = self.movies['title'].tolist()\n        matches = difflib.get_close_matches(input_title, titles, n=1, cutoff=0.6)\n        return matches[0] if matches else None\n\n    def content_recommendations(self, user_ratings: dict, top_n=10) -&gt; pd.DataFrame:\n        \"\"\"\n        Generate content-based movie recommendations using user ratings.\n\n        This method implements a content-based filtering algorithm that:\n        1. Matches user-provided movie titles to dataset titles using fuzzy matching\n        2. Calculates weighted similarity scores based on user ratings\n        3. Recommends movies most similar to highly-rated movies\n        4. Filters out movies the user has already rated\n        \"\"\"\n        print(f\"Debug: Input ratings: {user_ratings}\")\n\n        # Find movies that match user input\n        matched_movies = {}\n        for title, rating in user_ratings.items():\n            closest_match = self.find_closest_title(title)\n            if closest_match:\n                matched_movies[closest_match] = rating\n                print(f\"Debug: '{title}' matched to '{closest_match}'\")\n            else:\n                print(f\"Debug: No match found for '{title}'\")\n\n        if not matched_movies:\n            print(\"Debug: No matched movies found!\")\n            return pd.DataFrame(columns=['title', 'genres'])\n\n        # Calculate weighted similarity scores\n        sim_scores = np.zeros(len(self.movies))\n        total_weight = 0\n\n        for movie_title, rating in matched_movies.items():\n            if movie_title in self.indices:\n                movie_idx = self.indices[movie_title]\n                # Get similarity scores for this movie\n                movie_similarities = self.cosine_sim[movie_idx]\n                # Weight by user rating\n                sim_scores += movie_similarities * rating\n                total_weight += rating\n                print(f\"Debug: Added similarities for '{movie_title}' with weight {rating}\")\n\n        # Normalize by total weight\n        if total_weight &gt; 0:\n            sim_scores = sim_scores / total_weight\n\n        # Get movie indices sorted by similarity\n        sim_scores_indexed = list(enumerate(sim_scores))\n        sim_scores_indexed = sorted(sim_scores_indexed, key=lambda x: x[1], reverse=True)\n\n        # Filter out movies the user already rated and get top N\n        recommendations = []\n        for movie_idx, score in sim_scores_indexed:\n            movie_title = self.movies.iloc[movie_idx]['title']\n            if movie_title not in matched_movies and len(recommendations) &lt; top_n:\n                recommendations.append(movie_idx)\n                print(f\"Debug: Added recommendation: {movie_title} (score: {score:.3f})\")\n\n        if not recommendations:\n            print(\"Debug: No recommendations generated!\")\n            return pd.DataFrame(columns=['title', 'genres'])\n\n        result_df = self.movies.iloc[recommendations][['title', 'genres']]\n        print(f\"Debug: Returning {len(result_df)} recommendations\")\n        return result_df\n</code></pre>"},{"location":"reference/utils/#src.utils.ContentModel.__init__","title":"<code>__init__(movies)</code>","text":"<p>Initialize the ContentModel with movie data.</p> <p>This constructor sets up the TF-IDF vectorizer, computes the similarity matrix, and creates necessary mappings for efficient recommendation generation.</p> Source code in <code>src/utils.py</code> <pre><code>def __init__(self, movies: pd.DataFrame):\n    \"\"\"\n    Initialize the ContentModel with movie data.\n\n    This constructor sets up the TF-IDF vectorizer, computes the similarity matrix,\n    and creates necessary mappings for efficient recommendation generation.\n    \"\"\"\n    self.movies = movies\n    self.tfidf = TfidfVectorizer(stop_words='english')\n\n    # Create genre strings for TF-IDF\n    genre_strings = movies['genres'].apply(lambda x: ' '.join(x) if isinstance(x, list) else str(x))\n    self.tfidf_matrix = self.tfidf.fit_transform(genre_strings)\n\n    # Precompute cosine similarity matrix if not exists\n    if os.path.exists(\"cosine_sim.npy\"):\n        self.cosine_sim = np.load(\"cosine_sim.npy\")\n    else:\n        self.cosine_sim = cosine_similarity(self.tfidf_matrix, self.tfidf_matrix)\n        np.save(\"cosine_sim.npy\", self.cosine_sim)\n\n    # Create title to index mapping\n    self.indices = pd.Series(movies.index, index=movies['title']).drop_duplicates()\n</code></pre>"},{"location":"reference/utils/#src.utils.ContentModel.content_recommendations","title":"<code>content_recommendations(user_ratings, top_n=10)</code>","text":"<p>Generate content-based movie recommendations using user ratings.</p> <p>This method implements a content-based filtering algorithm that: 1. Matches user-provided movie titles to dataset titles using fuzzy matching 2. Calculates weighted similarity scores based on user ratings 3. Recommends movies most similar to highly-rated movies 4. Filters out movies the user has already rated</p> Source code in <code>src/utils.py</code> <pre><code>def content_recommendations(self, user_ratings: dict, top_n=10) -&gt; pd.DataFrame:\n    \"\"\"\n    Generate content-based movie recommendations using user ratings.\n\n    This method implements a content-based filtering algorithm that:\n    1. Matches user-provided movie titles to dataset titles using fuzzy matching\n    2. Calculates weighted similarity scores based on user ratings\n    3. Recommends movies most similar to highly-rated movies\n    4. Filters out movies the user has already rated\n    \"\"\"\n    print(f\"Debug: Input ratings: {user_ratings}\")\n\n    # Find movies that match user input\n    matched_movies = {}\n    for title, rating in user_ratings.items():\n        closest_match = self.find_closest_title(title)\n        if closest_match:\n            matched_movies[closest_match] = rating\n            print(f\"Debug: '{title}' matched to '{closest_match}'\")\n        else:\n            print(f\"Debug: No match found for '{title}'\")\n\n    if not matched_movies:\n        print(\"Debug: No matched movies found!\")\n        return pd.DataFrame(columns=['title', 'genres'])\n\n    # Calculate weighted similarity scores\n    sim_scores = np.zeros(len(self.movies))\n    total_weight = 0\n\n    for movie_title, rating in matched_movies.items():\n        if movie_title in self.indices:\n            movie_idx = self.indices[movie_title]\n            # Get similarity scores for this movie\n            movie_similarities = self.cosine_sim[movie_idx]\n            # Weight by user rating\n            sim_scores += movie_similarities * rating\n            total_weight += rating\n            print(f\"Debug: Added similarities for '{movie_title}' with weight {rating}\")\n\n    # Normalize by total weight\n    if total_weight &gt; 0:\n        sim_scores = sim_scores / total_weight\n\n    # Get movie indices sorted by similarity\n    sim_scores_indexed = list(enumerate(sim_scores))\n    sim_scores_indexed = sorted(sim_scores_indexed, key=lambda x: x[1], reverse=True)\n\n    # Filter out movies the user already rated and get top N\n    recommendations = []\n    for movie_idx, score in sim_scores_indexed:\n        movie_title = self.movies.iloc[movie_idx]['title']\n        if movie_title not in matched_movies and len(recommendations) &lt; top_n:\n            recommendations.append(movie_idx)\n            print(f\"Debug: Added recommendation: {movie_title} (score: {score:.3f})\")\n\n    if not recommendations:\n        print(\"Debug: No recommendations generated!\")\n        return pd.DataFrame(columns=['title', 'genres'])\n\n    result_df = self.movies.iloc[recommendations][['title', 'genres']]\n    print(f\"Debug: Returning {len(result_df)} recommendations\")\n    return result_df\n</code></pre>"},{"location":"reference/utils/#src.utils.ContentModel.find_closest_title","title":"<code>find_closest_title(input_title)</code>","text":"<p>Find the closest matching movie title in the dataset using fuzzy matching.</p> <p>This method uses difflib to find the most similar movie title to the user's input, helping to handle typos and variations in movie titles.</p> Source code in <code>src/utils.py</code> <pre><code>def find_closest_title(self, input_title: str) -&gt; str | None:\n    \"\"\"\n    Find the closest matching movie title in the dataset using fuzzy matching.\n\n    This method uses difflib to find the most similar movie title to the user's\n    input, helping to handle typos and variations in movie titles.\n    \"\"\"\n    titles = self.movies['title'].tolist()\n    matches = difflib.get_close_matches(input_title, titles, n=1, cutoff=0.6)\n    return matches[0] if matches else None\n</code></pre>"},{"location":"reference/utils/#src.utils.DataHandler","title":"<code>DataHandler</code>","text":"<p>A class for handling movie and rating data loading and preprocessing.</p> <p>This class provides methods to load movie and rating datasets from CSV files and preprocess the movie data by splitting genres and creating genre flags.</p> Source code in <code>src/utils.py</code> <pre><code>class DataHandler:\n    \"\"\"\n    A class for handling movie and rating data loading and preprocessing.\n\n    This class provides methods to load movie and rating datasets from CSV files\n    and preprocess the movie data by splitting genres and creating genre flags.\n    \"\"\"\n\n    def __init__(self, data_path: str):\n        \"\"\"\n        Initialize the DataHandler with the path to data directory.\n        \"\"\"\n        self.data_path = Path(data_path)\n\n    def load_data(self, movies_file: str, ratings_file: str) -&gt; (pd.DataFrame, pd.DataFrame):\n        \"\"\"\n        Load movie and rating data from CSV files.\n\n        This method reads the specified CSV files from the data directory\n        and returns them as pandas DataFrames.\n        \"\"\"\n        movies_path = self.data_path / movies_file\n        ratings_path = self.data_path / ratings_file\n\n        movies = pd.read_csv(movies_path)\n        ratings = pd.read_csv(ratings_path)\n        return movies, ratings\n\n    def preprocess_movies(self, movies: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"\n        Preprocess movie data by splitting genres and creating genre flags.\n\n        This method processes the 'genres' column by:\n        1. Splitting genre strings on '|' delimiter into lists\n        2. Creating binary flag columns for each unique genre\n        3. Setting flag values to 1 if movie belongs to that genre, 0 otherwise\n        \"\"\"\n        # Split genres into list\n        movies['genres'] = movies['genres'].str.split('|')\n\n        # Create genre flags\n        all_genres = set(genre for sublist in movies['genres'] for genre in sublist)\n        for genre in all_genres:\n            movies[genre] = movies['genres'].apply(lambda x: int(genre in x))\n\n        return movies\n</code></pre>"},{"location":"reference/utils/#src.utils.DataHandler.__init__","title":"<code>__init__(data_path)</code>","text":"<p>Initialize the DataHandler with the path to data directory.</p> Source code in <code>src/utils.py</code> <pre><code>def __init__(self, data_path: str):\n    \"\"\"\n    Initialize the DataHandler with the path to data directory.\n    \"\"\"\n    self.data_path = Path(data_path)\n</code></pre>"},{"location":"reference/utils/#src.utils.DataHandler.load_data","title":"<code>load_data(movies_file, ratings_file)</code>","text":"<p>Load movie and rating data from CSV files.</p> <p>This method reads the specified CSV files from the data directory and returns them as pandas DataFrames.</p> Source code in <code>src/utils.py</code> <pre><code>def load_data(self, movies_file: str, ratings_file: str) -&gt; (pd.DataFrame, pd.DataFrame):\n    \"\"\"\n    Load movie and rating data from CSV files.\n\n    This method reads the specified CSV files from the data directory\n    and returns them as pandas DataFrames.\n    \"\"\"\n    movies_path = self.data_path / movies_file\n    ratings_path = self.data_path / ratings_file\n\n    movies = pd.read_csv(movies_path)\n    ratings = pd.read_csv(ratings_path)\n    return movies, ratings\n</code></pre>"},{"location":"reference/utils/#src.utils.DataHandler.preprocess_movies","title":"<code>preprocess_movies(movies)</code>","text":"<p>Preprocess movie data by splitting genres and creating genre flags.</p> <p>This method processes the 'genres' column by: 1. Splitting genre strings on '|' delimiter into lists 2. Creating binary flag columns for each unique genre 3. Setting flag values to 1 if movie belongs to that genre, 0 otherwise</p> Source code in <code>src/utils.py</code> <pre><code>def preprocess_movies(self, movies: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    Preprocess movie data by splitting genres and creating genre flags.\n\n    This method processes the 'genres' column by:\n    1. Splitting genre strings on '|' delimiter into lists\n    2. Creating binary flag columns for each unique genre\n    3. Setting flag values to 1 if movie belongs to that genre, 0 otherwise\n    \"\"\"\n    # Split genres into list\n    movies['genres'] = movies['genres'].str.split('|')\n\n    # Create genre flags\n    all_genres = set(genre for sublist in movies['genres'] for genre in sublist)\n    for genre in all_genres:\n        movies[genre] = movies['genres'].apply(lambda x: int(genre in x))\n\n    return movies\n</code></pre>"},{"location":"reference/visualize/","title":"Visualization Module","text":""},{"location":"reference/visualize/#src.visualize.Visualizer","title":"<code>Visualizer</code>","text":"Source code in <code>src/visualize.py</code> <pre><code>class Visualizer:\n    @staticmethod\n    def plot_genre_distribution(movies: pd.DataFrame):\n        \"\"\"Plot distribution of movie genres\"\"\"\n        # Get all unique genres\n        all_genres = set()\n        for genres_list in movies['genres']:\n            if isinstance(genres_list, list):\n                all_genres.update(genres_list)\n\n        # Count genre occurrences\n        genre_counts = {}\n        for genre in all_genres:\n            if genre != '(no genres listed)':\n                genre_counts[genre] = movies[genre].sum()\n\n        # Plot\n        plt.figure(figsize=(12, 8))\n        genres = list(genre_counts.keys())\n        counts = list(genre_counts.values())\n\n        plt.barh(genres, counts)\n        plt.title('Movie Genre Distribution')\n        plt.xlabel('Number of Movies')\n        plt.tight_layout()\n        plt.savefig(f'{vis_dir}/genre_distribution.png', dpi=300, bbox_inches='tight')\n        plt.show()\n\n    @staticmethod\n    def plot_rating_distribution(ratings: pd.DataFrame):\n        \"\"\"Plot distribution of ratings\"\"\"\n        plt.figure(figsize=(10, 6))\n        sns.histplot(ratings['rating'], bins=10, kde=True)\n        plt.title('Rating Distribution')\n        plt.xlabel('Rating')\n        plt.ylabel('Frequency')\n        plt.tight_layout()\n        plt.savefig(f'{vis_dir}/rating_distribution.png', dpi=300, bbox_inches='tight')\n        plt.show()\n\n    @staticmethod\n    def plot_movies_per_year(movies: pd.DataFrame):\n        \"\"\"Plot number of movies released per year\"\"\"\n        # Extract year from title (assuming format like \"Movie Title (Year)\")\n        movies['year'] = movies['title'].str.extract(r'\\((\\d{4})\\)')\n        movies['year'] = pd.to_numeric(movies['year'], errors='coerce')\n\n        # Filter valid years\n        movies_with_year = movies.dropna(subset=['year'])\n        movies_with_year = movies_with_year[movies_with_year['year'] &gt;= 1900]\n\n        plt.figure(figsize=(12, 6))\n        year_counts = movies_with_year['year'].value_counts().sort_index()\n        plt.plot(year_counts.index, year_counts.values, linewidth=2)\n        plt.title('Number of Movies Released Per Year')\n        plt.xlabel('Year')\n        plt.ylabel('Number of Movies')\n        plt.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig(f'{vis_dir}/movies_per_year.png', dpi=300, bbox_inches='tight')\n        plt.show()\n\n    @staticmethod\n    def plot_top_rated_movies(df: pd.DataFrame, min_ratings=50):\n        \"\"\"Plot top rated movies with minimum number of ratings\"\"\"\n        # Calculate average rating and count for each movie\n        movie_stats = df.groupby('title').agg({\n            'rating': ['mean', 'count']\n        }).reset_index()\n\n        # Flatten column names\n        movie_stats.columns = ['title', 'avg_rating', 'rating_count']\n\n        # Filter movies with minimum ratings\n        popular_movies = movie_stats[movie_stats['rating_count'] &gt;= min_ratings]\n        top_movies = popular_movies.nlargest(15, 'avg_rating')\n\n        plt.figure(figsize=(10, 8))\n        plt.barh(top_movies['title'], top_movies['avg_rating'])\n        plt.title(f'Top 15 Highest Rated Movies (min {min_ratings} ratings)')\n        plt.xlabel('Average Rating')\n        plt.tight_layout()\n        plt.savefig(f'{vis_dir}/top_rated_movies.png', dpi=300, bbox_inches='tight')\n        plt.show()\n\n    @staticmethod\n    def plot_rating_trends(df: pd.DataFrame):\n        \"\"\"Plot rating trends over time\"\"\"\n        # Convert timestamp to datetime\n        df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')\n        df['year'] = df['datetime'].dt.year\n\n        # Calculate average rating per year\n        yearly_ratings = df.groupby('year')['rating'].mean()\n\n        plt.figure(figsize=(12, 6))\n        plt.plot(yearly_ratings.index, yearly_ratings.values, marker='o', linewidth=2)\n        plt.title('Average Rating Trends Over Time')\n        plt.xlabel('Year')\n        plt.ylabel('Average Rating')\n        plt.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig(f'{vis_dir}/rating_trends.png', dpi=300, bbox_inches='tight')\n        plt.show()\n</code></pre>"},{"location":"reference/visualize/#src.visualize.Visualizer.plot_genre_distribution","title":"<code>plot_genre_distribution(movies)</code>  <code>staticmethod</code>","text":"<p>Plot distribution of movie genres</p> Source code in <code>src/visualize.py</code> <pre><code>@staticmethod\ndef plot_genre_distribution(movies: pd.DataFrame):\n    \"\"\"Plot distribution of movie genres\"\"\"\n    # Get all unique genres\n    all_genres = set()\n    for genres_list in movies['genres']:\n        if isinstance(genres_list, list):\n            all_genres.update(genres_list)\n\n    # Count genre occurrences\n    genre_counts = {}\n    for genre in all_genres:\n        if genre != '(no genres listed)':\n            genre_counts[genre] = movies[genre].sum()\n\n    # Plot\n    plt.figure(figsize=(12, 8))\n    genres = list(genre_counts.keys())\n    counts = list(genre_counts.values())\n\n    plt.barh(genres, counts)\n    plt.title('Movie Genre Distribution')\n    plt.xlabel('Number of Movies')\n    plt.tight_layout()\n    plt.savefig(f'{vis_dir}/genre_distribution.png', dpi=300, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"reference/visualize/#src.visualize.Visualizer.plot_movies_per_year","title":"<code>plot_movies_per_year(movies)</code>  <code>staticmethod</code>","text":"<p>Plot number of movies released per year</p> Source code in <code>src/visualize.py</code> <pre><code>@staticmethod\ndef plot_movies_per_year(movies: pd.DataFrame):\n    \"\"\"Plot number of movies released per year\"\"\"\n    # Extract year from title (assuming format like \"Movie Title (Year)\")\n    movies['year'] = movies['title'].str.extract(r'\\((\\d{4})\\)')\n    movies['year'] = pd.to_numeric(movies['year'], errors='coerce')\n\n    # Filter valid years\n    movies_with_year = movies.dropna(subset=['year'])\n    movies_with_year = movies_with_year[movies_with_year['year'] &gt;= 1900]\n\n    plt.figure(figsize=(12, 6))\n    year_counts = movies_with_year['year'].value_counts().sort_index()\n    plt.plot(year_counts.index, year_counts.values, linewidth=2)\n    plt.title('Number of Movies Released Per Year')\n    plt.xlabel('Year')\n    plt.ylabel('Number of Movies')\n    plt.grid(True, alpha=0.3)\n    plt.tight_layout()\n    plt.savefig(f'{vis_dir}/movies_per_year.png', dpi=300, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"reference/visualize/#src.visualize.Visualizer.plot_rating_distribution","title":"<code>plot_rating_distribution(ratings)</code>  <code>staticmethod</code>","text":"<p>Plot distribution of ratings</p> Source code in <code>src/visualize.py</code> <pre><code>@staticmethod\ndef plot_rating_distribution(ratings: pd.DataFrame):\n    \"\"\"Plot distribution of ratings\"\"\"\n    plt.figure(figsize=(10, 6))\n    sns.histplot(ratings['rating'], bins=10, kde=True)\n    plt.title('Rating Distribution')\n    plt.xlabel('Rating')\n    plt.ylabel('Frequency')\n    plt.tight_layout()\n    plt.savefig(f'{vis_dir}/rating_distribution.png', dpi=300, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"reference/visualize/#src.visualize.Visualizer.plot_rating_trends","title":"<code>plot_rating_trends(df)</code>  <code>staticmethod</code>","text":"<p>Plot rating trends over time</p> Source code in <code>src/visualize.py</code> <pre><code>@staticmethod\ndef plot_rating_trends(df: pd.DataFrame):\n    \"\"\"Plot rating trends over time\"\"\"\n    # Convert timestamp to datetime\n    df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')\n    df['year'] = df['datetime'].dt.year\n\n    # Calculate average rating per year\n    yearly_ratings = df.groupby('year')['rating'].mean()\n\n    plt.figure(figsize=(12, 6))\n    plt.plot(yearly_ratings.index, yearly_ratings.values, marker='o', linewidth=2)\n    plt.title('Average Rating Trends Over Time')\n    plt.xlabel('Year')\n    plt.ylabel('Average Rating')\n    plt.grid(True, alpha=0.3)\n    plt.tight_layout()\n    plt.savefig(f'{vis_dir}/rating_trends.png', dpi=300, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"reference/visualize/#src.visualize.Visualizer.plot_top_rated_movies","title":"<code>plot_top_rated_movies(df, min_ratings=50)</code>  <code>staticmethod</code>","text":"<p>Plot top rated movies with minimum number of ratings</p> Source code in <code>src/visualize.py</code> <pre><code>@staticmethod\ndef plot_top_rated_movies(df: pd.DataFrame, min_ratings=50):\n    \"\"\"Plot top rated movies with minimum number of ratings\"\"\"\n    # Calculate average rating and count for each movie\n    movie_stats = df.groupby('title').agg({\n        'rating': ['mean', 'count']\n    }).reset_index()\n\n    # Flatten column names\n    movie_stats.columns = ['title', 'avg_rating', 'rating_count']\n\n    # Filter movies with minimum ratings\n    popular_movies = movie_stats[movie_stats['rating_count'] &gt;= min_ratings]\n    top_movies = popular_movies.nlargest(15, 'avg_rating')\n\n    plt.figure(figsize=(10, 8))\n    plt.barh(top_movies['title'], top_movies['avg_rating'])\n    plt.title(f'Top 15 Highest Rated Movies (min {min_ratings} ratings)')\n    plt.xlabel('Average Rating')\n    plt.tight_layout()\n    plt.savefig(f'{vis_dir}/top_rated_movies.png', dpi=300, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"reference/visualize/#src.visualize.create_all_visualizations","title":"<code>create_all_visualizations()</code>","text":"<p>Create all visualizations</p> Source code in <code>src/visualize.py</code> <pre><code>def create_all_visualizations():\n    \"\"\"Create all visualizations\"\"\"\n    print(\"Creating visualizations...\")\n\n    viz = Visualizer()\n\n    print(\"1. Genre distribution...\")\n    viz.plot_genre_distribution(movies)\n\n    print(\"2. Rating distribution...\")\n    viz.plot_rating_distribution(ratings)\n\n    print(\"3. Movies per year...\")\n    viz.plot_movies_per_year(movies)\n\n    print(\"4. Top rated movies...\")\n    viz.plot_top_rated_movies(df)\n\n    print(\"5. Rating trends...\")\n    viz.plot_rating_trends(df)\n\n    print(\"All visualizations saved!\")\n</code></pre>"}]}